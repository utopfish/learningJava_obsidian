# 前言

在本文将总结多线程并发编程中的常见面试题，主要核心线程生命周期、线程通信、并发包部分。主要分成 “并发编程” 和 “面试指南” 两 部分，在面试指南中将讨论并发相关面经。



## 1. 并发编程基础知识点

![[808_1.png]]

## [[线程状态转换]]
[[线程状态转换#新建（New）]]
[[线程状态转换#可运行（Runnable）]]
[[线程状态转换#阻塞（Blocking）]]
[[线程状态转换#无限期等待（Waiting）]]
[[线程状态转换#限期等待（Timed Waiting）]]
[[线程状态转换#死亡（Terminated）]]

## 2. [[Java实现多线程的方式]]

有三种使用线程的方法：

- 实现 Runnable 接口；
- 实现 Callable 接口；
- 继承 Thread 类。

实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。

[[Java实现多线程的方式#实现 Runnable 接口]]
[[Java实现多线程的方式#实现 Callable 接口]]
[[Java实现多线程的方式#继承 Thread 类]]
[[Java实现多线程的方式#实现接口 VS 继承 Thread]]
[[Java实现多线程的方式#三种方式的区别]]


#### volatile 关键字
1. Java 内存模型(JMM)。
2. 重排序与 happens-before 原则了解吗？
3. volatile 关键字的作用。
4. [[volatile 与 synchronized 的区别]]
5. [[volatile 关键字的如何保证内存可见性]]

#### synchronized 关键字
1. 简介
[[synchronized与lock的区别]]
[[Synchronized（对象锁）和Static Synchronized（类锁）区别]]
[[volatile 与 synchronized 的区别]]
#### ThreadLocal
1. 原理与作用。
2. 对应的内存泄露问题。

#### 线程池

#### AQS

#### 锁
在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突。这就是著名的并发性问题，因此需要引入**锁**。
1. 可重入锁和非可重入锁
2. 公平锁和非公平锁
3. 读写锁和排他锁
4. [[乐观锁和悲观锁]]
 悲观锁：假定会发生并发冲突
 乐观锁：假设不会发生并发冲突

[[Atomic 与 CAS 待完善]]

## 3. [[基础线程机制]]

## 4. [[中断]]

## 5. [[互斥同步]]


## 6. [[线程之间的协作]]

当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。

## 7. [[J.U.C - AQS]]
AQS 是  AbstractQueuedSynchronizer （抽象的队列式同步器）的简称，java.util.concurrent（J.U.C）大大提高了并发性能，AQS (AbstractQueuedSynchronizer) 被认为是 J.U.C 的核心。


## 8. [[J.U.C - 其它组件]]

## 9. [[线程不安全示例]]

## 10. Java 内存模型（[[JMM]]）


## 11. [[线程安全]]
一个类在可以被多个线程安全调用时就是线程安全的。
[[什么是线程安全]]
[[线程安全十万个为什么？]]
## 12. [[锁优化]]
这里的锁优化主要是指虚拟机对 synchronized 的优化

## 13. [[多线程开发良好的实践]]
## 14. [[线程池实现原理]]

# 第二部分：面试指南

#### [[什么是线程池？]]如果让你[[设计一个动态大小的线程池，如何设计，应该有哪些方法？]]线程池创建的方式？

##### 并发和并行
[[并发]]：两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。
[[并行]]：并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)

## 5. volatile 关键字的如何保证内存可见性

## 5. 什么是线程？线程和进程有什么区别？为什么要使用多线程
（1）[[线程和进程]]
（2）[[使用线程的原因]]
## 6. [[多线程共用一个数据变量需要注意什么]]？




## 7. 内存泄漏与内存溢出

### [[Java内存回收机制]]

### [[Java内存泄露引起原因]]
1. [[静态集合类]]
1. [[监听器]]
1. [[各种连接]]
1. [[内部类和外部模块等的引用]]
1.  [[多线程/单例模式（Singleton Pattern）#单例模式导致的内存泄露]]


## 8. [[如何减少线程上下文切换]]



## 9. 线程间通信和进程间通信

### [[线程间通信]]
- [[线程间通信#synchronized 同步]]
- [[线程间通信#while 轮询的方式]]
- [[线程间通信#wait notify 机制]]
- [[线程间通信#管道通信]]

### [[进程间通信]]
- [[进程间通信#管道（Pipe）]]
- [[进程间通信#命名管道（named pipe）]]
- [[进程间通信#信号（Signal）]]
- [[进程间通信#消息（Message）队列]]
- [[进程间通信#共享内存]]
- [[进程间通信#内存映射（mapped memory）]]
- [[进程间通信#信号量（semaphore）]]
- [[进程间通信#套接口（Socket）]]

## 10. [[同步和异步，阻塞和非阻塞]]？

#### 同步和异步
> 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)

**同步**：在发出一个同步调用时，在没有得到结果之前，该调用就不返回。
**异步**：在发出一个异步调用后，调用者不会立刻得到结果，该调用就返回了。

####阻塞和非阻塞
> 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.

**阻塞**：调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
**非阻塞**：在不能立刻得到结果之前，该调用不会阻塞当前线程。 




## 11. [[Java中的锁]]


## 12. [[并发包(J.U.C)]]下面，都用过什么






## 13. 从volatile说到,i++原子操作,线程安全问题

从 volatile 说到，i++原子操作，线程安全问题 - CSDN博客
https://blog.csdn.net/zbw18297786698/article/details/53420780
