## 基本特征
#### [[并发]]
#### [[共享]]
#### [[虚拟]]
#### [[异步]]

## 基本功能
#### [[进程管理]]
进程控制、进程同步、进程通信、死锁处理、处理机调度等。
#### [[内存管理（未完成）]]
内存分配、地址映射、内存保护与共享、虚拟内存等。
#### [[文件管理]]
文件存储空间的管理、目录管理、文件读写管理和保护等。
#### [[设备管理]]
完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

## [[系统调用]]
如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

## 宏内核和微内核
#### [[宏内核]]
宏内核是将操作系统功能作为一个紧密结合的整体放到内核。
#### [[微内核]]

## 中断类型
#### 外中断
由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。
#### 异常
由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。
#### 陷入
在用户程序中使用系统调用。
由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。
根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：
  1. **用户态(user mode)** : 用户态运行的进程或可以直接读取用户程序的数据。
  2. **系统态(kernel mode)**: 可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。

#### 用户态和内核态的切换
当在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态。

用户态切换到内核态的 3 种方式

1. **系统调用**
这是用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。例如 fork（）就是执行了一个创建新进程的系统调用。系统调用的机制和新是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。
1. **异常**
当 cpu 在执行运行在用户态下的程序时，发生了一些没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。
1. **外围设备的中断**
当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令而转到与中断信号对应的处理程序去执行，如果前面执行的指令时用户态下的程序，那么转换的过程自然就会是 由用户态到内核态的切换。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。

这三种方式是系统在运行时由用户态切换到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。从触发方式上看，切换方式都不一样，但从最终实际完成由用户态到内核态的切换操作来看，步骤有事一样的，都相当于执行了一个中断响应的过程。系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本一致。
运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能,就需要系统调用了！

也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

#### 资源访问

- 用户态无法访问内核态的资源，这防止了黑客通过应用程序攻击操作系统.
- 内核态可以通过一定的方式访问用户态的资源

## 系统调用
这些系统调用按功能大致可分为如下几类：

- 设备管理 ：完成设备的请求或释放，以及设备启动等功能。
- 文件管理 ：完成文件的读、写、创建及删除等功能。
- 进程控制 ：完成进程的创建、撤销、阻塞及唤醒等功能。
- 进程通信 ：完成进程之间的消息传递或信号传递等功能。
- [[内存管理（未完成）]] ：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

我在网上找了一个图，通过这个图可以很清晰的说明用户程序、系统调用、内核和硬件之间的关系。![[用户态和系统态.png]]