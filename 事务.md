## ACID
### 1. 原子性（Atomicity）
事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
### 2. 一致性（Consistency）
数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。
### 3. 隔离性（Isolation）
一个事务所做的修改在最终提交以前，对其它事务是不可见的。
### 4. 持久性（Durability）
一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

# 二、并发一致性问题
在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。
## 丢失修改
丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：$T_1$ 和 $T_2$ 两个事务都对一个数据进行修改，$T_1$先修改并提交生效，$T_2$ 随后修改，$T_2$ 的修改覆盖了 $T_1$ 的修改。
![[570_1.png]]

## 读脏数据
读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：$T_1$ 修改一个数据但未提交，$T_2$ 随后读取这个数据。如果 $T_1$ 撤销了这次修改，那么 $T_2$ 读取的数据是脏数据。
![[754_1.png]]


## 不可重复读
不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：$T_2$ 读取一个数据，$T_1$对该数据做了修改。如果 $T_1$再次读取这个数据，此时读取的结果和第一次读取的结果不同。
![[574_1.png]]

## 幻影读
幻读本质上也属于不可重复读的情况，$T_1$ 读取某个范围的数据，$T_2$ 在这个范围内插入新的数据，$T_1$ 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。
![[576_1.png]]

产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。


## 隔离级别

1. Read uncommitted: 未提交读，事务中的修改，即使没有提交，对其他事务也是可见的。存在脏读
2. Read committed: 提交读，大多数数据库系统的默认隔离级别(MySQL不是), 一个事务从开始到提交之前，所做的修改对其他事务不可见。解决脏读，存在幻读和不可重复读
3. repeatable read: 可重复读，该级别保证在同一事务中多次读取同样记录的结果是一致的。解决脏读和不可重复读，理论上存在幻读，但是在InnoDB引擎中解决了幻读
4. Serializable：可串行化，强制事务串行执行。

5. ![[fnwofeav.bmp]]