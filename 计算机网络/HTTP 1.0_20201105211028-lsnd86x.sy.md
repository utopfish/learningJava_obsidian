随着 HTTP 1.0 的发布，这个版本:

- 请求方式新增了POST，DELETE，PUT，HEADER等方式。
- 增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)。
- 扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输

在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。

## 请求头

一个简单请求的头信息

```
GET / HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```

复制代码可以看到在请求方法之后有 请求资源的位置 + 请求协议版本，之后是一些客户端的信息配置

## 响应头

```
一个简单响应的头信息(v1.0)
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
// 这是一个空行
...数据内容
```

复制代码服务端的响应头第一个就是 请求协议版本，后面紧跟着是这次请求的状态码、以及状态码的描述，之后的内容是一些关于返回内容的描述。

## Content-Type

在 HTTP 1.0 的时候，任何的资源都可以被传输，传输的格式呢也是多种多样的，客户端在收到响应体的内容的时候就是根据这个 `Content-Type` 去进行解析的。所以服务端返回时候必须带着这个字段。
一些常见的 `Content-Type` 可以参考 [对照表](https://tool.oschina.net/commons/)。
这些 `Content-Type` 有一个总称叫做MIME type。
关于`MIME type`，这里想播插一个小插曲:

> 在 chrome 浏览器中，当跨域请求回来的数据 MIME type 同跨域标签应有的 MIME type 不匹配时，浏览器会启动 CORB 保护数据不被泄漏。被保护的数据有: html、xml、json。(eg: script、img 标签所支持的 MIME type和他们都不一致)，所以服务端在返回资源的时候一定要对应返回正确的 Content-Type，以免浏览器屏蔽返回结果。
> 笔者遇到的问题是在 chrome v76 版本之后，跨域图片资源当请求回来的数据 Content-Type 不是 image/*，图片会被拦截，页面不展示图片。

## 特性

- 无状态：服务器不跟踪不记录请求过的状态。
- 无连接：浏览器每次请求都需要建立tcp连接。

## 无状态

对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录

## 无连接

无连接导致的性能缺陷有两种：

- 无法复用连接
  每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低
- 队头阻塞
  HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的
