## 4.1 问题
如果将前面 $1、2、3$ 中的三种背包问题混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？
## 4.2 01背包与完全背包的混合
考虑到01背包和完全背包中给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是 $O(V N)$。伪代码如下：
$for \ i = 1 \ to \ N$
$\quad if 第 i 件物品属于01背包$
$\quad \quad for \ v = V \ to \ C_i$
$\quad \quad \quad F[v] = max(F[v], F[v − C_i] + W_i)$
$\quad else \ if 第i件物品属于完全背包$
$\quad \quad for \ v = C_i \ to \ V$
$\quad \quad \quad F[v] = max(F[v], F[v − Ci] + W_i)$

## 4.3 再加上多重背包
如果再加上最多可以取有限次的多重背包式的物品，那么利用单调队列，也可以给出均摊 $O(V N)$ 的解法。

但如果不考虑单调队列算法的话，用将每个这类物品分成$O(\log M_i)$个01背包的物品的方法也已经很优了。

当然，最清晰的写法是调用我们前面给出的三个过程。
$for \ i = 1 \ to \ N$
$\quad if \ 第i件物品属于01背包$
$\quad \quad ZeroOnePack(F,C_i,W_i)$
$\quad else \ if \ 第i件物品属于完全背包$
$\quad \quad CompletePack(F,Ci,Wi)$
$\quad else \ if \ 第i件物品属于多重背包$
$\quad \quad \quad MultiplePack(F,Ci,Wi,Ni)$
在最初写出这三个过程的时候，可能完全没有想到它们会在这里混合应用。我想这体现了编程中抽象的威力。如果你一直就是以这种“抽象出过程”的方式写每一类背包问题的，也非常清楚它们的实现中细微的不同，那么在遇到混合三种背包问题的题目时，一定能很快想到上面简洁的解法，对吗？
## 4.4 小结
有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。
