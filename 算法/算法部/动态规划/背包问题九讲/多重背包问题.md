## 3.1 题目
有 $N$ 种物品和一个容量为 $V$ 的背包。第 $i$ 种物品最多有 $M_i$ 件可用，每件耗费的空间是 $C_i$，价值是 $W_i$。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。
## 3.2 基本算法
这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可。

因为对于第 $i$ 种物品有 $M_i+1$ 种策略：取 0 件，取 1 件……取 $M_i$ 件。令 $F[i, v]$表示前 $i$ 种物品恰放入一个容量为 $v$ 的背包的最大价值，则有状态转移方程：
$F[i，v] = max\{F[i − 1, v − k ∗ C_i] + k ∗ W_i| 0 ≤ k ≤ M_i\}$
复杂度是$O(V \sum M_i)$。

## 3.3 转化为01背包问题
另一种好想好写的基本方法是转化为01背包求解：把第 $i$ 种物品换成 $M_i$ 件01背包中的物品，则得到了物品数为 $\sum M_i$ 的01背包问题。直接求解之，复杂度仍然是 $O(V \sum M_i)$。
但是我们期望将它转化为01背包问题之后，能够像完全背包一样降低复杂度。

仍然考虑二进制的思想，我们考虑把第 $i$ 种物品换成若干件物品，使得原问题中第 $i$ 种物品可取的每种策略——取 $0 . . . M_i$ 件——均能等价于取若干件代换以后的物品。另外，取超过 $M_i$ 件的策略必不能出现。

方法是：将第 $i$ 种物品分成若干件01背包中的物品，其中每件物品有一个系数。这件物品的费用和价值均是原来的费用和价值乘以这个系数。令这些系数分别为$1, 2, 2^2. . . 2^{k−1}, M_i − 2^k + 1$，且 $k$ 是满足 $M_i − 2^k + 1 > 0$ 的最大整数。例如，如果$M_i$为 13，则相应的 $k = 3$，这种最多取 13 件的物品应被分成系数分别为 1, 2, 4, 6 的四件物品。

分成的这几件物品的系数和为$M_i$，表明不可能取多于 $M_i$ 件的第i种物品。另外这种方法也能保证对于 $0 . . . M_i$ 间的每一个整数，均可以用若干个系数的和表示。这里算法正确性的证明可以分$0 . . . 2^{k−1}$和$2^k. . . M_i$两段来分别讨论得出，希望读者自己思考尝试一下。

这样就将第 $i$ 种物品分成了$O(\log M_i)$种物品，将原问题转化为了复杂度为$O(V \sum \log M_i)$的01背包问题，是很大的改进。

下面给出$O(\log M)$时间处理一件多重背包中物品的过程：
$def \ MultiplePack(F,C,W,M)$
$\quad if \ C · M ≥ V$
$\quad \quad CompletePack(F,C,W)$
$\quad \quad return$
$\quad k := 1$
$\quad while k < M$
$\quad \quad ZeroOnePack(kC,kW)$
$\quad  \quad M := M − k$
$\quad  \quad k := 2k$
$\quad ZeroOnePack(C · M,W · M)$

希望你仔细体会这个伪代码，如果不太理解的话，不妨翻译成程序代码以后，单步执行几次，或者头脑加纸笔模拟一下，以加深理解。
## 3.4 O(VN)的算法
多重背包问题同样有$O(V N)$复杂度的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊$O(1)$的时间求解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。（TODO：是否在此插入单调队列的讲解呢？）
## 3.5 小结
在这一讲中，我们看到了将一个算法的复杂度由$O(V \sum M_i)$改进到$O(V \sum \log M_i)$的过程，还知道了存在复杂度为$O(V N)$的算法。

希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并将完整的程序代码写出来。
