命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。
![[命令模式现实世界类比2.png]]
## 真实世界类比
![[命令模式现实世界类比.png]]
## 方案
优秀的软件设计通常会将关注点进行分离， 而这往往会导致软件的分层。 最常见的例子： 一层负责用户图像界面； 另一层负责业务逻辑。 

代码中看上去就像这样： 一个 GUI 对象传递一些参数来调用一个业务逻辑对象。 这个过程通常被描述为一个对象发送请求给另一个对象。

![[命令模式方案1.png]]
命令模式建议 GUI 对象不直接提交这些请求。 你应该将请求的所有细节 （例如调用的对象、 方法名称和参数列表） 抽取出来组成命令类， 该类中仅包含一个用于触发请求的方法。

![[命令模式方案2.png]]
下一步是让所有命令实现相同的接口。 该接口通常只有一个没有任何参数的执行方法， 让你能在不和具体命令类耦合的情况下使用同一请求发送者执行不同命令。 此外还有额外的好处， 现在你能在运行时切换连接至发送者的命令对象， 以此改变发送者的行为。

你可能会注意到遗漏的一块拼图——请求的参数。 GUI 对象可以给业务层对象提供一些参数。 但执行命令方法没有任何参数， 所以我们如何将请求的详情发送给接收者呢？ 答案是： 使用数据对命令进行预先配置， 或者让其能够自行获取数据。

![[命令模式方案3.png]]



## 结构
![[命令模式结构.png]]



## 适用场景
如果你需要通过操作来参数化对象， 可使用命令模式。
如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。
如果你想要实现操作回滚功能， 可使用命令模式。
## 实现方式


声明仅有一个执行方法的命令接口。

抽取请求并使之成为实现命令接口的具体命令类。 每个类都必须有一组成员变量来保存请求参数和对于实际接收者对象的引用。 所有这些变量的数值都必须通过命令构造函数进行初始化。

找到担任发送者职责的类。 在这些类中添加保存命令的成员变量。 发送者只能通过命令接口与其命令进行交互。 发送者自身通常并不创建命令对象， 而是通过客户端代码获取。

修改发送者使其执行命令， 而非直接将请求发送给接收者。

客户端必须按照以下顺序来初始化对象：
- 创建接收者。
- 创建命令， 如有需要可将其关联至接收者。
- 创建发送者并将其与特定命令关联。
## 优点
单一职责原则。 你可以解耦触发和执行操作的类。

开闭原则。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。

你可以实现撤销和恢复功能。

你可以实现操作的延迟执行。

你可以将一组简单命令组合成一个复杂命令。
## 缺点
代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。
## 与其他模式的关系
[[责任链模式]]、 [[命令模式]]、 [[中介者模式]]和[[观察者模式]]用于处理请求发送者和接收者之间的不同连接方式：
- 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
- 命令在发送者和请求者之间建立单向连接。
- 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
- 观察者允许接收者动态地订阅或取消接收请求。

责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。

还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。

你可以同时使用命令和[[备忘录模式]]来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。

命令和[[策略模式]]看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。

- 你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。
- 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。

[[原型模式]]可用于保存命令的历史记录。

你可以将[[访问者模式]]视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。