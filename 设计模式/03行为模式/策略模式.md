策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。

![[策略模式现实世界类别.png]]

## 结构

![[策略模式结构.png]]

## 适用场景
当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。

当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。

如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。

如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。
## 实现方式
从上下文类中找出修改频率较高的算法 （也可能是用于在运行时选择某个算法变体的复杂条件运算符）。

声明该算法所有变体的通用策略接口。

将算法逐一抽取到各自的类中， 它们都必须实现策略接口。

在上下文类中添加一个成员变量用于保存对于策略对象的引用。 然后提供设置器以修改该成员变量。 上下文仅可通过策略接口同策略对象进行交互， 如有需要还可定义一个接口来让策略访问其数据。

客户端必须将上下文类与相应策略进行关联， 使上下文可以预期的方式完成其主要工作。
## 优点
你可以在运行时切换对象内的算法。

你可以将算法的实现和使用算法的代码隔离开来。

你可以使用组合来代替继承。

开闭原则。 你无需对上下文进行修改就能够引入新的策略。
## 缺点
如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。

客户端必须知晓策略间的不同——它需要选择合适的策略。

许多现代编程语言支持函数类型功能， 允许你在一组匿名函数中实现不同版本的算法。 这样， 你使用这些函数的方式就和使用策略对象时完全相同， 无需借助额外的类和接口来保持代码简洁。
## 与其他模式的关系


[[桥接模式]]、 [[状态模式]]和[[策略模式]] （在某种程度上包括[[适配器模式]]） 模式的接口非常相似。 实际上， 它们都基于[[组合模式]]——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。

[[命令模式]]和策略看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。

- 你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。
- 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。

[[装饰模式]]可让你更改对象的外表， 策略则让你能够改变其本质。

[[模板方法模式]]基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。

状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。