生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。
![[structure3.png]]

## 适用场景
使用生成器模式可避免 “重叠构造函数 （telescopic constructor）” 的出现。

当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。

使用生成器构造组合树或其他复杂对象。
## 实现方式
清晰地定义通用步骤， 确保它们可以制造所有形式的产品。 否则你将无法进一步实施该模式。
在基本生成器接口中声明这些步骤。
为每个形式的产品创建具体生成器类， 并实现其构造步骤。

不要忘记实现获取构造结果对象的方法。 你不能在生成器接口中声明该方法， 因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。
考虑创建主管类。 它可以使用同一生成器对象来封装多种构造产品的方式。
客户端代码会同时创建生成器和主管对象。 构造开始前， 客户端必须将生成器对象传递给主管对象。 通常情况下， 客户端只需调用主管类构造函数一次即可。 主管类使用生成器对象完成后续所有制造任务。 还有另一种方式， 那就是客户端可以将生成器对象直接传递给主管类的制造方法。

只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则， 客户端应当通过生成器获取构造结果。
## 优点
你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。
生成不同形式的产品时， 你可以复用相同的制造代码。
单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来。
## 缺点
由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。
## 与其他模式的关系

`生成器`重点关注如何分步生成复杂对象。 `抽象工厂`专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。

你可以在创建复杂[[组合模式]]树时使用`生成器`， 因为这可使其构造步骤以递归的方式运行。

你可以结合使用`生成器`和[[桥接模式]]： 主管类负责抽象工作， 各种不同的生成器负责实现工作。