享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。
![[享元模式现实世界类别.png]]

## 问题
游戏中的粒子特效，每个粒子 （一颗子弹、 一枚导弹或一块弹片） 都由包含完整数据的独立对象来表示。 当玩家在游戏中鏖战进入高潮后的某一时刻， 游戏将无法在剩余内存中载入新建粒子， 于是程序就崩溃了。
![[享元模式解决的问题.png]]
## 解决方案
仔细观察粒子（Particle）类， 你可能会注意到颜色 （color） 和精灵图 （sprite） 这两个成员变量所消耗的内存要比其他变量多得多。 更糟糕的是， 对于所有的粒子来说， 这两个成员变量所存储的数据几乎完全一样 （比如所有子弹的颜色和精灵图都一样）。

享元模式建议不在对象中存储外在状态， 而是将其传递给依赖于它的一个特殊方法。 

![[享元模式解决方案.png]]

## 结构
![[享元模式结构.png]]


## 适用场景
仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。
## 实现方式
将需要改写为享元的类成员变量拆分为两个部分：

- 内在状态： 包含不变的、 可在许多对象中重复使用的数据的成员变量。
- 外在状态： 包含每个对象各自不同的情景数据的成员变量

保留类中表示内在状态的成员变量， 并将其属性设置为不可修改。 这些变量仅可在构造函数中获得初始数值。

找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 并使用该参数代替成员变量。

你可以有选择地创建工厂类来管理享元缓存池， 它负责在新建享元时检查已有的享元。 如果选择使用工厂， 客户端就只能通过工厂来请求享元， 它们需要将享元的内在状态作为参数传递给工厂。

客户端必须存储和计算外在状态 （情景） 的数值， 因为只有这样才能调用享元对象的方法。 为了使用方便， 外在状态和引用享元的成员变量可以移动到单独的情景类中。
## 优点
如果程序中有很多相似对象， 那么你将可以节省大量内存。
## 缺点
你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。
代码会变得更加复杂。 团队中的新成员总是会问： ​ “为什么要像这样拆分一个实体的状态？”。
## 与其他模式的关系


你可以使用享元模式实现[[组合模式]]树的共享叶节点以节省内存。

享元展示了如何生成大量的小型对象， [[外观模式]]则展示了如何用一个对象来代表整个子系统。

如果你能将对象的所有共享状态简化为一个享元对象， 那么享元就和[[单例模式]]类似了。 但这两个模式有两个根本性的不同。
- 只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。
- 单例对象可以是可变的。 享元对象是不可变的。