## 前言

主要核心线程生命周期、线程通信、并发包部分。


#### [[线程状态转换]]
![[线程状态转换.png]]
[[线程状态转换#新建（New）]]
[[线程状态转换#可运行（Runnable）]]
[[线程状态转换#阻塞（Blocking）]]
[[线程状态转换#无限期等待（Waiting）]]
[[线程状态转换#限期等待（Timed Waiting）]]
[[线程状态转换#死亡（Terminated）]]

####  [[Java实现多线程的方式]]

有三种使用线程的方法：

- 实现 Runnable 接口；
- 实现 Callable 接口；
- 继承 Thread 类。

实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。

[[Java实现多线程的方式#实现 Runnable 接口]]
[[Java实现多线程的方式#实现 Callable 接口]]
[[Java实现多线程的方式#继承 Thread 类]]
[[Java实现多线程的方式#实现接口 VS 继承 Thread]]
[[Java实现多线程的方式#三种方式的区别]]


#### volatile 关键字
1. Java 内存模型(JMM)。
2. 重排序与 happens-before 原则了解吗？
3. [[volatile 关键字的作用]]。
4. **禁止进行指令重排序**
5. volatile能保证可见性不能保证原子性：`java.util.concurrent.atomic`包提供原子性操作，对自增，自减，加法，减法进行了封装。`atomic`使用`CAS`实现原子性操作。`CAS`实际上是利用处理器提供的 `CMPXCHG` 指令实现的，而处理器执行 `CMPXCHG` 指令是一个原子性操作。
6. [[volatile 与 synchronized 的区别]]
7. [[volatile 关键字的如何保证内存可见性]]

#### synchronized 关键字
1. 简介
[[synchronized与lock的区别]]
[[Synchronized（对象锁）和Static Synchronized（类锁）区别]]
[[volatile 与 synchronized 的区别]]
synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且 在释放锁之前会将对变量的修改刷新到主存当中，因此可以保证可见性
不能由于 synchronized 和 Lock 可以让线程串行执行同步代码，就说它们可以保证指令不会发生重排序
#### ThreadLocal
1. 原理与作用。
2. 对应的内存泄露问题。

#### 线程池

#### AQS

## 锁
在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突。这就是著名的并发性问题，因此需要引入**锁**。

**无锁状态**，**[[偏向锁]]状态**，**[[轻量级锁]]状态**和**[[重量级锁]]状态**，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。
1. 可重入锁和非可重入锁
2. 公平锁和非公平锁
3. 读写锁和排他锁
4. [[乐观锁和悲观锁]]
 悲观锁：假定会发生并发冲突
 乐观锁：假设不会发生并发冲突
5. [[偏向锁]]
6. [[自旋锁]]
[[CAS]]

#### 3. [[基础线程机制]]

#### 4. [[中断]]

#### 5. [[互斥同步]]
[[线程间的同步的方式]]
互斥量（Mutex），信号量（Semphares），事件（Event）

#### 6. [[线程之间的协作]]

当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。

####  [[J.U.C - AQS]]
AQS 是  AbstractQueuedSynchronizer （抽象的队列式同步器）的简称，java.util.concurrent（J.U.C）大大提高了并发性能，AQS (AbstractQueuedSynchronizer) 被认为是 J.U.C 的核心。


#### 8. [[J.U.C - 其它组件]]

#### 9. [[线程不安全示例]]

#### 10. [[JMM]]


#### 11. [[线程安全]]
一个类在可以被多个线程安全调用时就是线程安全的。
[[什么是线程安全]]
[[线程安全十万个为什么？]]
#### 12. [[锁优化]]
这里的锁优化主要是指虚拟机对 synchronized 的优化

#### 13. [[多线程开发良好的实践]]
#### 14. [[线程池实现原理]]

