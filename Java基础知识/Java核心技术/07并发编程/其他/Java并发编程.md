## 前言
主要核心线程生命周期、线程通信、并发包部分。
####  [[Java实现多线程的方式]]
有三种使用线程的方法：
- 实现 Runnable 接口；
- 实现 Callable 接口；
- 继承 Thread 类。

实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。

[[Java实现多线程的方式#实现 Runnable 接口]]
[[Java实现多线程的方式#实现 Callable 接口]]
[[Java实现多线程的方式#继承 Thread 类]]
[[Java实现多线程的方式#实现接口 VS 继承 Thread]]
[[Java实现多线程的方式#三种方式的区别]]



## 锁
在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突。这就是著名的并发性问题，因此需要引入**锁**。

**无锁状态**，**[[偏向锁]]状态**，**[[轻量级锁]]状态**和**[[重量级锁]]状态**，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。
1. 可重入锁和非可重入锁
2. 公平锁和非公平锁
3. 读写锁和排他锁
4. [[乐观锁和悲观锁]]
 悲观锁：假定会发生并发冲突
 乐观锁：假设不会发生并发冲突
5. [[偏向锁]]
6. [[自旋锁]]
7. [[CAS]]

#### 3. [[基础线程机制]]

#### 4. [[中断]]

#### 5. [[互斥同步]]
[[线程间的同步的方式]]
互斥量（Mutex），信号量（Semphares），事件（Event）

#### 6. [[线程之间的协作]]

当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。

####  [[J.U.C - AQS]]
AQS 是  AbstractQueuedSynchronizer （抽象的队列式同步器）的简称，java.util.concurrent（J.U.C）大大提高了并发性能，AQS (AbstractQueuedSynchronizer) 被认为是 J.U.C 的核心。


#### 8. [[J.U.C - 其它组件]]

#### 9. [[线程不安全示例]]

#### 10. [[JMM]]


#### 11. [[线程安全]]
一个类在可以被多个线程安全调用时就是线程安全的。
[[什么是线程安全]]
[[线程安全十万个为什么？]]
#### 12. [[锁优化]]
这里的锁优化主要是指虚拟机对 synchronized 的优化

#### 13. [[多线程开发良好的实践]]
#### 14. [[线程池实现原理]]

