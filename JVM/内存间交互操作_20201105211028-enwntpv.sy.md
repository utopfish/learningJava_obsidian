## 8 个操作

Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。

- read（读取）：**作用于主内存变量**，把一个变量的值从主内存传输到工作内存中。
- load（载入）：**作用于工作内存变量**，在 read 之后执行，把 read 得到的值放入工作内存的变量副本中，以便随后的load动作使用。
- use（使用）：**作用于工作内存变量**，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- assign（赋值）：**作用于工作内存变量**，把一个从执行引擎接收到的值赋给工作内存的变量。
- store（存储）：**作用于工作内存变量**，把工作内存的一个变量的值传送到主内存中。
- write（写入）：**作用于主内存变量**，在 store 之后执行，把 store 得到的值放入主内存的变量中。
- lock（锁定）：**作用于主内存的变量**，把一个变量标识为一条线程独占状态
- unlock（解锁）：**作用于主内存变量**，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

## 执行规则：

Java内存模型还规定了在执行上述八种基本操作时，必须满足如下

1. 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。
2. 不允许read和load、store和write操作之一单独出现。
3. 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
4. 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
5. 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
6. 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。
7. 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。
8. 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
9. 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。
