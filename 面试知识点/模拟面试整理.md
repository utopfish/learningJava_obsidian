####  1. JVM内存模型讲一下
JVM内存模型分为栈区与堆区。栈区中有程序计数器，虚拟机栈，本地方法栈。
程序计数器是唯一不会出现 `OutOfMemoryError` 的地方，主要实现代码的流程控制，多线程情况下用来记录当前线程执行的位置。
虚拟机栈在每个线程创建时会创建单独的运行时栈，每次方法调用中都会在其中创建栈帧，保存方法的局部遍历表和部分结果、并参与方法的调用和返回。
本地方法栈与虚拟机栈类似，但是虚拟机栈是为java虚拟机执行字节码服务的，本地方法栈是为执行native方法服务的，主要是执行一些在c或c++上执行起来更方便的本地方法。
堆区结构区分为1.7和1.8。1.8之前堆区分为GC堆和方法区。
堆分为新生代和老生代。Eden 区和两个 Survivor 区都属于新生代，在一次新生代垃圾回收后，eden区对象如果还存活就进入s0或s1区，年龄达到默认值15岁后，进入老生代。
方法区也称永生代，是线程共享的区域，用于存储被虚拟机加载的类信息，常量，静态变量等，方法区还包括运行时常量池，1.8之后方法区有人也成为永久代被本地内存中的元数据区取代。这样相比于由于使用了直接内存，出现内存溢出的概率就减小了。
运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）
#### jvm gc 优化
Major GC的速度一般会比Minor GC慢10倍以上。
**在编程层面**：
应该缩短对象生命周期，避免对象被添加到old代。避免大方法；避免一个变量跨方法调用，且被不同方法调用；对象不用了要及时的清空对象， 比如引用变量a，清空a, a=null。
**在jvm设置层面**：
增大survivor space和老年代空间，或调低触发并发GC的比率。
#### 2. 锁升级过程
锁的状态由低到高依次为：无锁、偏向锁、轻量级锁、重量级锁。目的是为了提高获得锁和释放锁的效率。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200603161323889.png)
#### 3.ConcurrentHashMap1.7与1.8的区别
ConcurrentHashMap 是采用的 "分段锁" 思想来实现了线程安全，1.7中将其内部数据将数据分为数个“段（Segment）”，默认段数 DEFAULT_CONCURRENCY_LEVEL =16。每个段使用ReentrantLock（分段锁）进行加锁，多线程操作如果涉及不同的段则并发执行，同一个段则进行锁竞争与等待。
1.8之后重新使用了synchronized+CAS的方法实现对每一行进行加锁，加入了红黑树，在同一个桶中链表长度达到8并且桶大小大于64的情况下链表转为红黑树。大小在64以下rehash既可。
#### 4.HashMap扩容过程,线程安全问题（闭环）
多线程下HashMap的rehash的头插法可能导致链表成环，所以1.8之后使用了尾插法。
#### 5.对象的生命周期
1. 类加载检验：检查这个符号代表的类是否被加载、解析和初始化过。
2. 分配内存：在虚拟机中为对象分配内存，内存分配包括指针碰撞和空闲列表。 指针碰撞将用过的内存整理到一起，没用过的内存在一起，中间有一个分解指针，只要指针向没用过的方向移动对象内存大小即可。GC使用serial、ParNew回收器。空闲列表维护一个记录内存可用的列表，分配时找一个大小合适的内存块，再更新列表记录。GC使用CMS。
3. 初始化零值：将分配的内存空间都初始化为零值。
4. 设置对象头：将对象的所属类、元数据信息、对象hash码、GC年龄等存入对象头中。
5. 执行初始化（init）方法：执行初始化方法。
对象内存包括对象头、实例数据、对齐填充。hotSpot自带内存管理系统要求对象起始地址为8字节的整数倍。
#### 6.类加载过程
![](https://pic4.zhimg.com/80/v2-ecf6c3d0f5146029e9693d6223d23afb_1440w.jpg)
- 加载:加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。
字节码来源：一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译。
类加载器：一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。
- 验证：保证加载进来的字节流符合虚拟机规范，不会造成安全错误。包括：文件格式验证、元数据验证、字节码验证、符号引用验证。
- 准备：主要是为类变量分配内存，并且赋予初值。
- 解析：将常量池内的符号引用替换为直接引用的过程。
- 初始化：初始化阶段是执行初始化方法 \<clinit> ()方法的过程。
#### 7.GC算法
进行垃圾回收先要判断对象是否已死。包括引用计数法和可达性分析。引用计数法每当一个对象被引用一次后计数器加一，为 0 时就没有被引用。这个方法简单高效，但会出现两个对象相互引用的情况。可达性分析是通过一系列 GC Roots 对象作为起点，向下搜索，如果一个对向没有被搜索到，表明其是不可用的。常用的 GC Roots 对象包括：虚拟机栈中引用的对象，本地方法栈中引用的对象，方法区中类静态属性引用的对象，方法区常量引用的对象。
垃圾回收算法包括标记清除法、标记整理法、复制法、分代回收法。
- 标记清除法先标出所有不需要被回收的对象，再统一回收所有未被标记的对象。这样会有大量不完整碎片。
- 复制法为解决效率，将内存分为两块，每次使用其中一块，内存使用完后将存活对象放入另一块，再把之前的空间清空。
- 标记整理法：标记过程仍然与“标记-清除”算法一样，但后续步骤是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
- 分代回收法：在新生代中使用复制法，在老生代中使用标记清除或标记整理。

#### 8.收集器：
- **Serial 收集器**：单线程，新生代采用复制算法，老年代采用标记-整理算法。 
![ Serial 收集器 ](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm垃圾回收/46873026.png)
- ParNew收集器：多线程，除了使用多线程进行垃圾收集外，其余行为和 Serial 收集器完全一样。
![ParNew 收集器 ](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm垃圾回收/22018368.png)
- **Parallel Scavenge 收集器**：Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）新生代采用标记-复制算法，老年代采用标记-整理算法，这是 JDK1.8 默认收集器。
- **CMS收集器**：CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。    
	- 初始标记：暂停所有线程，初始标记仅仅只是标记一下GC Roots能直接关联到的对象 ，速度很快；
	- 并发标记： 同时开启 GC 和用户线程，GC线程对对象进行标记，并记录这个阶段对象引用更新的情况。
	- 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。
	- 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。![CMS 垃圾收集器 ](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm垃圾回收/CMS收集器.png)

JVM在暂停的时候，需要选准一个时机。**安全点**的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。
- **G1 收集器**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。G1从整体来看是基于标记-整理算法实现的收集器
G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活。
![jvm-g1-memory-management-model](https://itqiankun.oss-cn-beijing.aliyuncs.com/picture/blogArticles/2020-06-17/1592387078.png)
G1 收集线程在标记阶段和应用程序线程并发执行，标记结束后，G1 也就知道哪些区块基本上是垃圾，存活对象极少，G1 会先从这些区块下手，因为从这些区块能很快释放得到很大的可用空间，这也是为什么 G1 被取名为 Garbage-First 的原因。
G1 使用了停顿预测模型来满足用户指定的停顿时间目标，并基于目标来选择进行垃圾回收的区块数量。G1 采用增量回收的方式，每次回收一些区块，而不是整堆回收。

我们要知道 G1 不是一个实时收集器，它会尽力满足我们的停顿时间要求，但也不是绝对的，它基于之前垃圾收集的数据统计，估计出在用户指定的停顿时间内能收集多少个区块。
#### 9.hashMap 1.7和1.8
在插入法上：
- **JDK1.7用的是头插法**。
- **JDK1.8及之后使用的都是尾插法**

因为 JDK1.7 是用单链表进行的当采用头插法时会容易出现逆序且环形链表死循环问题。但是在 JDK1.8 之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。

在扩容后数据存储位置的计算方式上：
在计算 hash 值的时候， JDK1.7 用了 9 次扰动处理= 4 次位运算+ 5 次异或，而 JDK1.8 只用了 2 次扰动处理= 1 次位运算+ 1 次异或。
1. JDK1.7 的时候是直接用 hash 值和需要扩容的二进制数进行 & （这里就是为什么扩容的时候为啥一定必须是 2 的多少次幂的原因所在，因为如果只有 2 的 n 次幂的情况时最后一位二进制数才一定是 1 ，这样能最大程度减少 hash 碰撞）（hash值 & length-1）

在底层实现上：
1. JDK1.7 的时候使用的是**数组+ 单链表**的数据结构。
1. JDK1.8 及之后时，使用的是**数组+链表+红黑树**的数据结构（当链表的深度达到 8 的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从 O（n） 变成 O（logN） 提高了效率）
#### 10.sync关键字原理，锁膨胀过程
Java中的每个对象都可以作为锁. 具体变现为以下3中形式.

    对于普通同步方法, 锁是当前实例对象.
    对于静态同步方法, 锁是当前类的Class对象.
    对于同步方法块, 锁是synchronized括号里配置的对象.
偏向锁是针对于一个线程而言的, 线程获得锁之后就不会再有解锁等操作了, 这样可以省略很多开销. 假如有两个线程来竞争该锁话, 那么偏向锁就失效了, 进而升级成轻量级锁了.
#### 11. JDK1.6 之后的 synchronized 关键字底层做了哪些优化？
锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。
#### 12.谈谈 synchronized 和 ReentrantLock 的区别
**“可重入锁”** 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。
synchronized 是依赖于 JVM 实现的。
ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。
相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：
	**等待可中断**: ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
    **可实现公平锁** : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。
    **可实现选择性通知**（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。

#### 13.线程池
线程池提供了一种限制和管理资源的办法，好处有：
    降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
    提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
    提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

ThreadPoolExecutor 3 个最重要的参数：

    corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。
    maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
    workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
![](https://upload-images.jianshu.io/upload_images/11183270-a01aea078d7f4178.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)
step1.调用ThreadPoolExecutor的execute提交线程，首先检查CorePool，如果CorePool内的线程小于CorePoolSize，新创建线程执行任务。
step2.如果当前CorePool内的线程大于等于CorePoolSize，那么将线程加入到BlockingQueue。
step3.如果不能加入BlockingQueue，在小于MaxPoolSize的情况下创建线程执行任务。
step4.如果线程数大于等于MaxPoolSize，那么执行拒绝策略。
**饱和策略**：
`ThreadPoolExecutor.AbortPolicy`：抛出 `RejectedExecutionException` 来拒绝新任务的处理。
`ThreadPoolExecutor.CallerRunsPolicy`：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
`ThreadPoolExecutor.DiscardPolicy`： 不处理新任务，直接丢弃掉。
`ThreadPoolExecutor.DiscardOldestPolicy`： 此策略将丢弃最早的未处理的任务请求。
#### 14. 三次握手和四次挥手
#### 15.http与https
HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。
HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。
**HTTPS 相对于 HTTP 的改进**
客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证 。
#### CAP理论
-   **一致性（Consistence）** : 所有节点访问同一份最新的数据副本
-   **可用性（Availability）**: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。
-   **分区容错性（Partition tolerance）** : 分布式系统出现网络分区的时候，仍然能够对外提供服务。

网络分区：分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。

CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C，因此，**分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。**

#### mysql的ACID。
**一致性保证**
从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段；从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据。
**原子性保证**
利用Innodb的undo log。当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。
**持久性保证**
利用Innodb的redo log。Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。
**binlog**
binlog用于记录数据库执行的写入性操作信息，以二进制的形式保存在磁盘中。binlog是mysql的逻辑日志，并且由Server层进行记录。在实际应用中，binlog的主要使用场景有两个，分别是主从复制和数据恢复。
与redo/undo log区别：
层次不同：binlog在server层，redo/undo log在innodb层。
记录内容不同：binlog记录事务操作内容，redo/undo log记录的是每个页的修改情况，属于物理日志+逻辑日志结合的方式（redo log物理到页，页内采用逻辑日志，undo log采用的是逻辑日志）。
记录的时机不同：binlog是在事务最终commit前写入的，redo/undo日志在事务执行过程中会不断的写入。
-   逻辑日志：可以简单理解为记录的就是sql语句。
-   物理日志：因为mysql数据最终是保存在数据页中的，物理日志记录的就是数据页变更。
#### MySQL如何优化，回表问题
覆盖索引（covering index）指一个查询语句的执行只用从索引页中就能够取得，避免进行回表，减少了IO操作。
#### Mysql 查询的具体步骤
1.  客户端发送一条**查询**给服务器；
2.  服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；
3.  服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；
4.  MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；
5.  将结果返回给客户端。

#### Mysql 读写分离可能导致的问题，如何解决
有时候可能会遇到执行完写操作后，立刻去读发现读不到或者读到旧状态的尴尬场景。
 **强制走主库**：让一部分查询操作，强制去主库查询。
**判断主备无延迟**：使用 show slave status 语句结果中的部分值来判断主从同步的延迟时间，如果有延迟，则一直等待到无延迟后执行。
**等GTID 方案**：全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。
MySQL 在执行完事务后，会将该事务的 GTID 会给客户端，然后客户端可以使用该命令去要执行读操作的从库中执行，等待该 GTID，等待成功后，再执行读操作；如果等待超时，则去主库执行读操作，或者再换一个从库执行上述流程。
#### Mysql 分表可能导致的问题
垂直分表：要拿到完整的信息的查询次数增加。
水平分表：一般单表行数超过5000万就得分表，如果单表的数据比较复杂那可能2000万甚至1000万就得分了。
1. 按范围路由：容易切，之前的数据都不需要移动。
2. 哈希路由：好处就是分的很均匀，但是新增数据又得分表，以前的数据都得动。
3. 一张表来存储路由关系：导致每次查询都得查两次，并且如果路由表太大了，那路由表又成为瓶颈了！
#### redis的zet，跳表如何实现，怎么增删
[[zset底层存储结构#skiplist数据结构]]
核心点主要是包括一个dict对象和一个skiplist对象。dict保存key/value，key为元素，value为分值；skiplist保存的有序的元素列表，每个元素包括元素和分值。查找，删除，插入$O(\log N)$，查找的时间复杂度跟二分查找是一样的。
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzY1LzZjLzY1Mzc5ZjA2NTFiYzNhN2NmZDEzYWI4Njk0YzRkMjZjLmpwZw?x-oss-process=image/format,png)
删除操作，如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到删除结点的前驱接待你，然后通过指针操作完成删除。
#### Redis的rehash
**渐进式哈希(rehashing)**的机制来提高`dict`的缩放效率**
#### 消息队列的好处和产生的问题
好处：应用解耦，异步，削峰。
缺点：系统可用性差，复杂度增加，数据一致性的保证
#### Redis怎么实现锁（难，待解决）
#### 算法：岛屿数量
BFS+设置一个全局变量。
#### 7.redis持久化方式以及应用场景
redis持久化方案分为[[RDB]]和[[AOF]]两种。
对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。
与AOF相比，在恢复大的数据时候，RDB方式更快一些。
AOF通过配置同步策略基本能够达到实时持久化数据。

#### 7.微服务
#### 1.8为什么引入红黑树
#### sync关键字原理
#### 10.ReentrantLock原理，实现
ReentrantLock实现了Lock接口，加锁和解锁都需要显式写出，注意一定要在适当时候unlock。ReentrantLock的内部类Sync继承了AQS，分为公平锁FairSync和非公平锁NonfairSync。
#### 11.CAS的引入解决什么？
解决多线程并行情况下使用锁造成性能损耗的一种机制。包含三个操作数：内存位置（V），预期原值（A），新值（B）。如果内存位置的值与预期值匹配，那么处理器会自动将该位置的值更新为新值；否则，处理器不做任何操作。
#### 2.HashMap原理

-   操作系统也有一些知识点是常问的：
    -   线程和进程的区别
    -   进程间的通信方式
    -   内存管理有哪几种方式?
    -   常见的页置换[算法](/jump/super-jump/word?word=%E7%AE%97%E6%B3%95)有哪些？
    -   什么是虚拟内存？


#### 线程池
#### 线程池的阻塞队列为什么不用ArrayList?
arrayList底层为数组，不适合处理先进先出的任务。
4.TCP握手与挥手
5.红黑树
6.ReentrantLock原理，实现（AQS）
7.分布式锁
8.HashMap扩容
9.微服务 注册中心，远程过程调用
1.ArrayList相关
2.Jvm运行时（新 生代，老年代）
3.缓存穿透缓存雪崩 2
4.数据库 索引数据结构，联合索引 问题 
5.单例 模式 
6.Java线程池
7.数据库与缓存一致性，redo日志，binlog，先写数据库再更新缓存
8.redis一致性算法，集群拓展后rehash
9.b+树 查询索引查询了几次
10.程序代码中的各个变量和方法放再堆还是栈
11.4层负载+7层，网络OSI模型，负载均衡算法/策略
12.redis 缓存删除原理
13.数据库掉电数据如何恢复，数据库写入远离，数据库事务隔离 ，幻影读，脏读
14.如何解决缓存雪崩
15.RSA原理