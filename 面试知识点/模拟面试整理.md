####  1. JVM内存模型讲一下
JVM内存模型分为栈区与堆区。栈区中有程序计数器，虚拟机栈，本地方法栈。
程序计数器是唯一不会出现 `OutOfMemoryError` 的地方，主要实现代码的流程控制，多线程情况下用来记录当前线程执行的位置。
虚拟机栈在每个线程创建时会创建单独的运行时栈，每次方法调用中都会在其中创建栈帧，保存方法的局部遍历表和部分结果、并参与方法的调用和返回。
本地方法栈与虚拟机栈类似，但是虚拟机栈是为java虚拟机执行字节码服务的，本地方法栈是为执行native方法服务的，主要是执行一些在c或c++上执行起来更方便的本地方法。
堆区结构区分为1.7和1.8。1.8之前堆区分为GC堆和方法区。
堆分为新生代和老生代。Eden 区和两个 Survivor 区都属于新生代，在一次新生代垃圾回收后，eden区对象如果还存活就进入s0或s1区，年龄达到默认值15岁后，进入老生代。
方法区也称永生代，是线程共享的区域，用于存储被虚拟机加载的类信息，常量，静态变量等，方法区还包括运行时常量池，1.8之后方法区有人也成为永久代被本地内存中的元数据区取代。这样相比于由于使用了直接内存，出现内存溢出的概率就减小了。
运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）
#### 2. 锁升级过程
#### 3.ConcurrentHashMap1.7与1.8的区别
ConcurrentHashMap 是采用的 "分段锁" 思想来实现了线程安全，1.7中将其内部数据将数据分为数个“段（Segment）”，默认段数 DEFAULT_CONCURRENCY_LEVEL =16。每个段使用ReentrantLock（分段锁）进行加锁，多线程操作如果涉及不同的段则并发执行，同一个段则进行锁竞争与等待。
1.8之后重新使用了synchronized+CAS的方法实现对每一行进行加锁，加入了红黑树，在同一个桶中链表长度达到8并且桶大小大于64的情况下链表转为红黑树。大小在64以下rehash既可。
#### 4.HashMap扩容过程,线程安全问题（闭环）
#### 5.对象的生命周期
1. 类加载检验：检查这个符号代表的类是否被加载、解析和初始化过。
2. 分配内存：在虚拟机中为对象分配内存，内存分配包括指针碰撞和空闲列表。 指针碰撞将用过的内存整理到一起，没用过的内存在一起，中间有一个分解指针，只要指针向没用过的方向移动对象内存大小即可。GC使用serial、ParNew回收器。空闲列表维护一个记录内存可用的列表，分配时找一个大小合适的内存块，再更新列表记录。GC使用CMS。
3. 初始化零值：将分配的内存空间都初始化为零值。
4. 设置对象头：将对象的所属类、元数据信息、对象hash码、GC年龄等存入对象头中。
5. 执行初始化（init）方法：执行初始化方法。
对象内存包括对象头、实例数据、对齐填充。hotSpot自带内存管理系统要求对象起始地址为8字节的整数倍。
#### 6.类加载过程
![](https://pic4.zhimg.com/80/v2-ecf6c3d0f5146029e9693d6223d23afb_1440w.jpg)
- 加载:加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。
字节码来源：一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译。
类加载器：一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。
- 验证：保证加载进来的字节流符合虚拟机规范，不会造成安全错误。包括：文件格式验证、元数据验证、字节码验证、符号引用验证。
- 准备：主要是为类变量分配内存，并且赋予初值。
- 解析：将常量池内的符号引用替换为直接引用的过程。
- 初始化：初始化阶段是执行初始化方法 \<clinit> ()方法的过程。
#### 7.GC算法
进行垃圾回收先要判断对象是否已死。包括引用计数法和可达性分析。引用计数法每当一个对象被引用一次后计数器加一，为 0 时就没有被引用。这个方法简单高效，但会出现两个对象相互引用的情况。可达性分析是通过一系列 GC Roots 对象作为起点，向下搜索，如果一个对向没有被搜索到，表明其是不可用的。常用的 GC Roots 对象包括：虚拟机栈中引用的对象，本地方法栈中引用的对象，方法区中类静态属性引用的对象，方法区常量引用的对象。
垃圾回收算法包括标记清除法、标记整理法、复制法、分代回收法。
- 标记清除法先标出所有不需要被回收的对象，再统一回收所有未被标记的对象。这样会有大量不完整碎片。
- 复制法为解决效率，将内存分为两块，每次使用其中一块，内存使用完后将存活对象放入另一块，再把之前的空间清空。
- 标记整理法：标记过程仍然与“标记-清除”算法一样，但后续步骤是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
- 分代回收法：在新生代中使用复制法，在老生代中使用标记清除或标记整理。

#### 8.收集器：
- Serial 收集器：单线程，新生代采用复制算法，老年代采用标记-整理算法。 
![ Serial 收集器 ](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm垃圾回收/46873026.png)
- ParNew收集器：多线程，除了使用多线程进行垃圾收集外，其余行为和 Serial 收集器完全一样。
![ParNew 收集器 ](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm垃圾回收/22018368.png)
- Parallel Scavenge 收集器：Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）新生代采用标记-复制算法，老年代采用标记-整理算法，这是 JDK1.8 默认收集器。
- CMS收集器：CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。    
	- 初始标记：暂停所有线程，记录与GC root相连的对象 ，速度很快；
	- 并发标记： 同时开启 GC 和用户线程，GC线程对对向进行标记，并记录这个阶段对象引用更新的情况。
	- 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
	- 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。![CMS 垃圾收集器 ](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm垃圾回收/CMS收集器.png)
- G1 收集器：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。
#### 9.hashMap 1.7和1.8
在插入法上：
- **JDK1.7用的是头插法**。
- **JDK1.8及之后使用的都是尾插法**

因为 JDK1.7 是用单链表进行的当采用头插法时会容易出现逆序且环形链表死循环问题。但是在 JDK1.8 之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。

在扩容后数据存储位置的计算方式上：
在计算 hash 值的时候， JDK1.7 用了 9 次扰动处理= 4 次位运算+ 5 次异或，而 JDK1.8 只用了 2 次扰动处理= 1 次位运算+ 1 次异或。
1. JDK1.7 的时候是直接用 hash 值和需要扩容的二进制数进行 & （这里就是为什么扩容的时候为啥一定必须是 2 的多少次幂的原因所在，因为如果只有 2 的 n 次幂的情况时最后一位二进制数才一定是 1 ，这样能最大程度减少 hash 碰撞）（hash值 & length-1）

在底层实现上：
1. JDK1.7 的时候使用的是**数组+ 单链表**的数据结构。
1. JDK1.8 及之后时，使用的是**数组+链表+红黑树**的数据结构（当链表的深度达到 8 的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从 O（n） 变成 O（logN） 提高了效率）
#### 10.sync关键字原理，锁膨胀过程
Java中的每个对象都可以作为锁. 具体变现为以下3中形式.

    对于普通同步方法, 锁是当前实例对象.
    对于静态同步方法, 锁是当前类的Class对象.
    对于同步方法块, 锁是synchronized括号里配置的对象.
偏向锁是针对于一个线程而言的, 线程获得锁之后就不会再有解锁等操作了, 这样可以省略很多开销. 假如有两个线程来竞争该锁话, 那么偏向锁就失效了, 进而升级成轻量级锁了.
#### 11. JDK1.6 之后的 synchronized 关键字底层做了哪些优化？
锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。
#### 12.谈谈 synchronized 和 ReentrantLock 的区别
**“可重入锁”** 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。
synchronized 是依赖于 JVM 实现的。
ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。
相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：
	**等待可中断**: ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
    **可实现公平锁** : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。
    **可实现选择性通知**（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。

#### 13.线程池
线程池提供了一种限制和管理资源的办法，好处有：
    降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
    提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
    提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

ThreadPoolExecutor 3 个最重要的参数：

    corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。
    maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
    workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
step1.调用ThreadPoolExecutor的execute提交线程，首先检查CorePool，如果CorePool内的线程小于CorePoolSize，新创建线程执行任务。
step2.如果当前CorePool内的线程大于等于CorePoolSize，那么将线程加入到BlockingQueue。
step3.如果不能加入BlockingQueue，在小于MaxPoolSize的情况下创建线程执行任务。
step4.如果线程数大于等于MaxPoolSize，那么执行拒绝策略。

#### 7.redis持久化方式以及应用场景
7.微服务
8.1.8为什么引入红黑树
9.sync关键字原理，
10.ReentrantLock原理，实现
11.CAS的引入解决什么
2.HashMap原理



4.TCP握手与挥手
5.红黑树
6.ReentrantLock原理，实现（AQS）
7.分布式锁
8.HashMap扩容
9.微服务 注册中心，远程过程调用
1.ArrayList相关
2.Jvm运行时（新 生代，老年代）
3.缓存穿透缓存雪崩 2
4.数据库 索引数据结构，联合索引 问题 
5.单例 模式 
6.Java线程池
7.数据库与缓存一致性，redo日志，binlog，先写数据库再更新缓存
8.redis一致性算法，集群拓展后rehash
9.b+树 查询索引查询了几次
10.程序代码中的各个变量和方法放再堆还是栈
11.4层负载+7层，网络OSI模型，负载均衡算法/策略
12.redis 缓存删除原理
13.数据库掉电数据如何恢复，数据库写入远离，数据库事务隔离 ，幻影读，脏读
14.如何解决缓存雪崩
15.RSA原理