#### ((20201105211028-nad5kqt "什么是线程池？")) 如果让你((20201105211028-c4jmq7h "设计一个动态大小的线程池，如何设计，应该有哪些方法？")) ]]线程池创建的方式？
{: id="20201105211031-zit1a1a"}

#### 并发和并行
{: id="20201105211031-e8vy83n"}

[[并发]]：两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。
[[并行]]：并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)
{: id="20201105211031-z4gqdn0"}

#### volatile 关键字的如何保证内存可见性
{: id="20201105211031-fowrndv"}

#### 什么是线程？线程和进程有什么区别？为什么要使用多线程
{: id="20201105211031-wub0sj0"}

（1）[[线程和进程]]
（2）[[使用线程的原因]]
{: id="20201105211031-68smkp1"}

#### [[多线程共用一个数据变量需要注意什么]]？
{: id="20201105211031-i54qpb9"}

#### 内存泄漏与内存溢出
{: id="20201105211031-vmrthdq"}

#### [[Java内存回收机制]]
{: id="20201105211031-w9t87ot"}

#### [[Java内存泄露引起原因]]
{: id="20201105211031-zfgbqpm"}

1. {: id="20201105211031-us9bmut"}[[静态集合类]]
2. {: id="20201105211031-5rv50ou"}[[监听器]]
3. {: id="20201105211031-ei0lx6h"}[[各种连接]]
4. {: id="20201105211031-s2sphqg"}[[内部类和外部模块等的引用]]
5. {: id="20201105211031-zh8vtrw"}[[多线程/单例模式（Singleton Pattern）#单例模式导致的内存泄露]]
{: id="20201105211031-6ixbezu"}

#### [[如何减少线程上下文切换]]
{: id="20201105211031-mtye06a"}

#### 线程间通信和进程间通信
{: id="20201105211031-p9kxxaq"}

** [[线程间通信]]**
{: id="20201105211031-7dpqb8s"}

- {: id="20201105211031-inv0lel"}[[线程间通信#synchronized 同步]]
- {: id="20201105211031-62a1ezp"}[[线程间通信#while 轮询的方式]]
- {: id="20201105211031-oeg1f71"}[[线程间通信#wait notify 机制]]
- {: id="20201105211031-bnfccgl"}[[线程间通信#管道通信]]
{: id="20201105211031-5sbi5c9"}

#### [[进程通信 IPC（Inter-Process Communication）]]
{: id="20201105211031-j211qqp"}

- {: id="20201105211031-744g26h"}[[进程通信 IPC（Inter-Process Communication）#管道（Pipe）]]
- {: id="20201105211031-7643fzi"}[[进程通信 IPC（Inter-Process Communication）#命名管道（named pipe）]]
- {: id="20201105211031-u709ef7"}[[进程通信 IPC（Inter-Process Communication）#信号（Signal）]]
- {: id="20201105211031-s8x2wqa"}[[进程通信 IPC（Inter-Process Communication）#消息（Message）队列]]
- {: id="20201105211031-w6mhs92"}[[进程通信 IPC（Inter-Process Communication）#共享内存]]
- {: id="20201105211031-m3t37gn"}[[进程通信 IPC（Inter-Process Communication）#内存映射（mapped memory）]]
- {: id="20201105211031-kgm2453"}[[进程通信 IPC（Inter-Process Communication）#信号量（semaphore）]]
- {: id="20201105211031-wmrj83b"}[[进程通信 IPC（Inter-Process Communication）#套接口（Socket）]]
{: id="20201105211031-1bqf2i0"}

#### [[同步和异步，阻塞和非阻塞]]？
{: id="20201105211031-t5eobap"}

#### 同步和异步
{: id="20201105211031-05j9jej"}

> 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)
> {: id="20201105211031-op785z1"}
{: id="20201105211031-zcs17v9"}

**同步**：在发出一个同步调用时，在没有得到结果之前，该调用就不返回。
**异步**：在发出一个异步调用后，调用者不会立刻得到结果，该调用就返回了。
{: id="20201105211031-p0xfoxu"}

#### 阻塞和非阻塞
{: id="20201105211031-it3raww"}

> 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.
> {: id="20201105211031-hnrxbo7"}
{: id="20201105211031-zkox80a"}

**阻塞**：调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
**非阻塞**：在不能立刻得到结果之前，该调用不会阻塞当前线程。
{: id="20201105211031-eoyvolc"}

#### [[Java中的锁]]
{: id="20201105211031-h84ly64"}

#### [[并发包(J.U.C)]]下面，都用过什么
{: id="20201105211031-0yiveqv"}

#### 从volatile说到,i++原子操作,线程安全问题
{: id="20201105211031-dh071dr"}

[从 volatile 说到，i++原子操作，线程安全问题](https://blog.csdn.net/zbw18297786698/article/details/53420780)
{: id="20201105211031-fnsjlue"}
