#### 多路复用定义？
单线程活单进程同时检查若干个文件描述符是否具有可以执行IO操作的能力，本质上是在提高资源的利用率。
[[IO 模型]]
#### epoll的两种工作模式  
[[select、poll、epoll]]

#### mysql索引类型？聚簇索引和非聚簇索引的区别？  
[[聚簇索引和非聚簇索引]]
#### count(\*) 和count(列) 的哪个更快？  
cout(\*)返回表中的记录数，行为空也会被统计。
count(列名)对指定列的行数进行统计，行为null不做统计。
count(\*)和count(1)两个函数没有区别。通过执行计划查看，他们的执行计划是一样的。
**执行效率上**：
-   列名为主键，count(列名)会比count(1)快
-   列名不为主键，count(1)会比count(列名)快


#### innodb和myism对count的支持？为什么innodb不像myism存储记录总条数
```
SELECT count(\*) FROM table1;
```
如果执行上述代码
对于MyISAM：
因为MySQL对该引擎的count有对应优化，精确的行数会被储存在存储引擎中，因此此类没有where条件的单表总行数查询会迅速返回结果。
对于InnoDB：
因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。

#### CAP 理论？zookeeper 属于哪种？
[[CAP理论]]
 **ZooKeeper 中保证了 CP**
 设计一个支持数十万的QPS的秒杀系统，库存只有一个？
**QPS**：每秒查询率
**TPS**：Transactions Per Second（每秒传输的事物处理个数）,即服务器**每秒**处理的事务数
[[秒杀架构设计]]
#### 100 亿数据找到最大的 1000 个数字。
1. **全排序**，最基础的办法。
2. **局部排序**，使用小根堆来实现。
3. **分治法**。
a、将 100 亿个数据分为 1000 个大分区，每个区 1000 万个数据
b、每个大分区再细分成 100 个小分区。总共就有 1000\*100=10 万个分区
c、计算每个小分区上最大的 1000 个数。
d、合并每个大分区细分出来的小分区。每个大分区有 100 个小分区，我们已经找出了每个小分区的前 1000 个数。将这 100 个分区的 1000\*100 个数合并，找出每个大分区的前 1000 个数。
e、合并大分区。我们有 1000 个大分区，上一步已找出每个大分区的前 1000 个数。我们将这 1000\*1000 个数合并，找出前 1000，这 1000 个数就是所有数据中最大的 1000 个数。
4. **Hash法**。如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。

#### 快排平均复杂度，怎么得到的？
[[快速排序（Quick Sort）]]

#### mysql的存储引擎有哪些？索引数据结构有哪些？
[[MySQL]]
#### 什么情况下我们会用到事务？事务的四个特性？隔离级别？mysql默认的是什么？怎么实现的？
6，head请求讲一下，http状态码讲一下，tcp和udp的区别有哪些？
7，进程，线程和协程的区别
8，linux命令——查看网络端口，查看所有文件的大小
9，三种string的区别
10，redis的过期删除？
11，写个单利模式，问了一下项目，结束




#### redis实现分布式锁的详细过程
在分布式环境中使用到的锁就是分布式锁，只要存在跨JVM操作，并且存在共享资源竞争问题，就是必须使用到分布式锁的场景。
常见的分布式锁有以下几种：  
1.基于数据库（乐观锁）实现分布式锁  
2.基于Redis的分布式锁Redisson  
3.基于Zookeeper实现分布式锁

通过Redis创建一个唯一的key，如果当前线程能创建这个唯一的key,则表示当前线程获取到锁。
使用setnx、getset、expire、del这4个redis命令实现

#### 鸡蛋摔楼的问题
这个方法重点，是要**利用好第一颗鸡蛋，最大效率地把100层高楼划分成N个更小数目的区间。**一个比较直观和流行的答案是，**将鸡蛋从【要检查的楼层\* 1/N】层开始扔下去，逐层检查。**
https://zhuanlan.zhihu.com/p/33898752
#### CDN了解吗？
内容分发网络（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。
在用户和我们的服务器之间加一个缓存机制，通过这个缓存机制动态获取IP地址根据地理位置，让用户到最近的服务器访问。
#### LRU算法的实现，如果get和set的复杂度为o(1)，要怎么实现
#### 实习中的这个布隆过滤器的具体怎么用的？原理是什么？优缺点是什么？怎么改善？数据量有多少？
6，关系和非关系数据库的区别，为什么用mongo，当时mysql达到性能瓶颈了吗？数据量是多少？
7，Mongo的索引类型？如何查询的？数据格式和数据类型有哪些？
8，说一说mysql和mongodb的区别吧
#### jvm的内存模型和jmm说一下吧
#### g1和cms如何进行选择的？去掉java层面，考虑gc调优主要要怎么做？
从性能的角度看，通常关注三个方面，内存占用（footprint）、延时（Latency）和吞吐量（throughput）。
掌握GC调优信息收集途径。
#### Chrome是多线程还是多进程
多进程
browser进程：浏览器的主进程，负责界面的显示，用户交互，子进程的管理，提供存储等功能
GPU Process:GPU进程，负责绘制 repaint 重绘后的 UI 界面
Utility Network:网络进程，负责页面网络资源的加载
插件进程：有插件会显示插件进程
render进程：内核进程，前端工程师开发和关注的界面，我们用户开发的进程就是在里面跑的
#### 一个订单表，有订单ID，用户ID，下单时间，三个场景：a.查询所有用户的订单 b.查询一天内的所有订单 c.查询某一天某个用户的订单，尽量少的建立索引，怎么建
建立两个索引：第一个是日期索引，因为b要求查询某一天；第二个是组合索引，用户user\_id，订单id，下单日期date。
因为c用到了三个，同时在建立索引时，将三个都建立上，另外由于索引结构中，int类型最佳，其次是date，所以将date放在后面。
####  MySQL 主从同步延迟的原因及解决办法
Mysql的主从同步就是当master（主库）发生数据变化的时候，会实时同步到slave（从库）。不管是delete、update、insert，还是创建函数、存储过程，都是在master上，当master有操作的时候，slave会快速的接受到这些操作，从而做同步。
#### # 二段式提交协议和三段式提交协议（2PC和3PC）
**2PC**
主要有两个阶段：
1.  准备阶段
2.  提交阶段

主要步骤如下：  
1.  步骤一，协调者询问参与者是否可以提交。  
1. 步骤二，参与者告知提交者可以提交。  
1. 步骤三，协调者让参与者发送提交请求。  
1. 步骤四，参与者提交完毕后告知协调者已经提交完毕。

在上面步骤三中，如果协调者发送提交请求给了一半的参与者之后就出了问题，那么就会出现有长时间阻塞的情况。
**3PC**
三段式提交是二段式提交的改进，主要就是为了解决二段式提交长时间阻塞的问题。
实现上，主要是加入了一个“预提交阶段”。
主要有三个阶段：

准备阶段
预提交阶段（下面的步骤三和步骤四）
提交阶段
主要步骤如下：
1. 协调者询问参与者是否可以提交。
1. 参与者告知提交者可以提交。
1. 如果所有参与者都可以提交，协调者会将这个信息告知参与者。
1. 单个参与者知道所有参与者都准备完毕可以提交，向协调者发送“预提交”请求。
1. 协调者让参与者发送提交请求。
1. 参与者提交完毕后告知协调者已经提交完毕。

在三段式提交情况下，如果在预提交阶段出现了协调者宕机的情况，是不需要回滚事物的。
如果是在提交阶段出现了协调者宕机的情况，可以通过时延来自动提交。（因为可以确定其他参与者也会提交，一致性就得以保证）

#### git rebase
变基操作，
多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。每次合并再push后，分支看上去会很乱。

```
$ git log --graph --pretty=oneline --abbrev-commit
* d1be385 (HEAD -> master, origin/master) init hello
*   e5e69f1 Merge branch 'dev'
|\  
| *   57c53ab (origin/dev, dev) fix env conflict
| |\  
| | * 7a5e5dd add env
| * | 7bd91f1 add new env
| |/  
* |   12a631b merged bug fix 101
|\ \  
| * | 4c805e2 fix bug 101
|/ /  
* |   e1e9c68 merge with no-ff
|\ \  
| |/  
| * f52c633 add merge
|/  
*   cf810e4 conflict fixed
```
把分叉的提交历史“整理”成一条直线，看上去更直观。

#### restFul 风格
Rest架构的主要原则：

```undefined
1.网络上的所有事物都被抽象为资源
2.每个资源都有一个唯一的资源标识符
3.同一个资源具有多种表现形式(xml,json等)
4.对资源的各种操作不会改变资源标识符
5.所有的操作都是无状态的
```
#### HTTP协议 状态码以及请求头

|状态码|解释|
|:---|:---|
|1xx|信息，请求收到，继续处理
|2xx|成功，行为被成功地接受、理解和采纳
|3xx|重定向，为了完成请求，必须进一步执行的动作
|4xx|客户端错误，请求包含语法错误或者请求无法实现
|5xx|服务器错误，服务器不能实现一种明显无效的请求

Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）
ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个 html 文件，如果被修改了，其 Etag 也会别修改。
Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。
Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。
#### 实现“附近的人”的方式原理
## GeoHash算法

GeoHash算法就是将经纬度编码，将二维变一维，把二维的空间经纬度数据编码成一个字符串从而实现给地址位置分区的一种算法。实现GeoHash算法分为三个步骤：
首先将经纬度变成二进制；
将经纬度合并，经度为奇数位，纬度为偶数位；
按照Base32进行编码。
redis 和mysql 可以用binlog 同步全量数据
 hash表，jdk1.8后的hashtable很有说头
 一致性hash
 mysql 索引
 多写的分布式一致性原理
 高并发系统设计
 boss的压力测试，hash表，一致性hash，设计库存服务的系统设计，表结构，一致性原理
 java的treemap
 java如何实现并发（Thread runable）
 http1和http2
 restful编程风格
 如何实现微信的二维码登陆
 数据库innodb如何实现啥来着
MySQL复合索引
反射 反射的弊端
进程间怎么通信
管道 有名管道 套接字 消息队列 信号量

线程间通信
MyISAM和InnoDB差别
多路IO模型 NIO

前四种都是同步IO

像listen()、send()、recv()这些接口都是阻塞的，一问一答型的。这就给网络编程带来了一个问题，如果在调用send的时候，线程将被阻塞，在此期间，无法执行任何运算或相应任何的网络请求。于是有了多路IO模型，一个socket可以多次accept多次，比如Java中的selcetor 不断轮询多喝socket的状态，只有当socket真正有读写事件的时候，才会调用实际的IO读写操作，还有想Golang里的select+多个channel，这样只需要一个线程就可以管理多个socket，能减少大量资源占用。

非阻塞IO模型

在非阻塞IO模型中，用户进程不需要主动询问对方是否准备好数据与否，比如进程发出read操作，如果对方没有准备好，会返回一个error，这表示对方没有准备好，但是进程并不会阻塞在这一步，而是继续执行，等对方准备好数据后，再去调用它。

异步IO

异步IO是真正意义上的非阻塞IO，用户进程发起read操作后，立刻就可以开始做其他事，而另一方面，当他收到一个异步请求时，会立即返回一个值，所以不会对用户进程产生任何阻塞，等数据准备完后，再将数据拷贝到用户内存，当这一切都完成后，再给用户进程发送一个signal，告诉他read操作完成了。

非阻塞IO和异步IO的区别

虽然非阻塞IO在大多时间内不会被阻塞，但是它要求进程去主动监察对方数据是不是准备好了，一旦准备好了，会再次要求进程调用接收函数将数据拷贝过来。而异步IO完全不管这些，就像吧IO操作外包掉，等他人做完再发信号通知，这个期间内，进程不要检查也不用主动的去拷贝。


虚拟内存
虚拟内存使得应用程序认为它拥有连续的可用内存，这样一来，就在逻辑层面上扩大了内存容量。但是实际上，只是把比较常用的内存片段取出来了而已，还有部分资源是放在磁盘存储器上的。需要的时候再进行数据交换。

调度方式有，分页式，段式，段页式。比较流行方式是段页式，他结合了前两者的优点，以页为单位替换，以段为单位使用。

常见的替换替换算法有4种，随机算法，先进先出算法，LRU算法，最优算法。 比较常使用的是LRU算法，他在redis里也有使用，当redis的内存满了的时候就是使用LRU算法替换掉旧内存。


.进程 线程 协程 ，协程跟线程的差别
3.time-wait 出现在tcp的什么阶段，如果高并发的情况下time-wait会出现什么状况
4.http与https区别，https加密过程
mysql主从复制，又问如果发现主从同步数据延迟很大是什么原因
redis怎么实现排行榜，用什么数据结构，具体怎么实现
git命令，问我熟悉哪些，又问了个git rebase了解吗

场景题：
10个磁盘，每个磁盘1亿数据，找出最大的1000个数，要求时间复杂度、空间复杂度尽可能小。说思路，然后会问你复杂度多少，再让你优化。
让你来做微信附近的人，你怎么实现？怎么快速找到离你最近的10个人？没答上来，面试官提示了好几次，思路和方向是对的，但是我就是没答到点，他很无奈哈哈。


  
